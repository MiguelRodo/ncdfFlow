% Generated by roxygen2 (4.0.0): do not edit by hand
\docType{class}
\name{ncdfFlowList-class}
\alias{Subset,ncdfFlowList,filter-method}
\alias{Subset,ncdfFlowList,filterResultList-method}
\alias{[[,ncdfFlowList,character-method}
\alias{[[,ncdfFlowList,logical-method}
\alias{[[,ncdfFlowList,numeric-method}
\alias{colnames,ncdfFlowList-method}
\alias{densityplot,formula,ncdfFlowList-method}
\alias{filter,ncdfFlowList,filter-method}
\alias{length,ncdfFlowList-method}
\alias{ncdfFlowList-class}
\alias{pData,ncdfFlowList-method}
\alias{pData<-,ncdfFlowList,data.frame-method}
\alias{phenoData,ncdfFlowList-method}
\alias{sampleNames,ncdfFlowList-method}
\alias{show,ncdfFlowList-method}
\alias{split,ncdfFlowList,factor-method}
\alias{xyplot,formula,ncdfFlowList-method}
\title{a class that stores multiple ncdfFlowSet objects}
\usage{
\S4method{filter}{ncdfFlowList,filter}(x, filter, method = "missing",
  sides = "missing", circular = "missing", init = "missing")

\S4method{[[}{ncdfFlowList,numeric}(x, i, j, ...)

\S4method{[[}{ncdfFlowList,logical}(x, i, j, ...)

\S4method{[[}{ncdfFlowList,character}(x, i, j, ...)

\S4method{length}{ncdfFlowList}(x)

\S4method{show}{ncdfFlowList}(object)

\S4method{sampleNames}{ncdfFlowList}(object)

\S4method{split}{ncdfFlowList,factor}(x, f, drop = FALSE, ...)

\S4method{phenoData}{ncdfFlowList}(object)

\S4method{pData}{ncdfFlowList}(object)

\S4method{colnames}{ncdfFlowList}(x)

\S4method{xyplot}{formula,ncdfFlowList}(x, data, ...)

\S4method{densityplot}{formula,ncdfFlowList}(x, data, ...)

\S4method{Subset}{ncdfFlowList,filterResultList}(x, subset, select, ...)

\S4method{Subset}{ncdfFlowList,filter}(x, subset, ...)
}
\arguments{
\item{x}{a univariate or multivariate time series.}

\item{filter}{a vector of filter coefficients in reverse time order
    (as for AR or MA coefficients).}

\item{method}{Either \code{"convolution"} or \code{"recursive"} (and
    can be abbreviated). If \code{"convolution"} a moving average is
    used: if \code{"recursive"} an autoregression is used.}

\item{sides}{for convolution filters only. If \code{sides = 1} the
    filter coefficients are for past values only; if \code{sides = 2}
    they are centred around lag 0.  In this case the length of the
    filter should be odd, but if it is even, more of the filter
    is forward in time than backward.}

\item{circular}{for convolution filters only.  If \code{TRUE}, wrap
    the filter around the ends of the series, otherwise assume
    external values are missing (\code{NA}).}

\item{init}{for recursive filters only. Specifies the initial values
    of the time series just prior to the start value, in reverse
    time order. The default is a set of zeros.}

\item{i}{
    indices specifying elements to extract or replace.  Indices are
    \code{numeric} or \code{character} vectors or empty (missing) or
    \code{NULL}.  Numeric values are coerced to integer as by
    \code{\link{as.integer}} (and hence truncated towards zero).
    Character vectors will be matched to the \code{\link{names}} of the
    object (or for matrices/arrays, the \code{\link{dimnames}}):
    see \sQuote{Character indices} below for further details.

    For \code{[}-indexing only: \code{i}, \code{j}, \code{\dots} can be
    logical vectors, indicating elements/slices to select.  Such vectors
    are recycled if necessary to match the corresponding extent.
    \code{i}, \code{j}, \code{\dots} can also be negative integers,
    indicating elements/slices to leave out of the selection.

    When indexing arrays by \code{[} a single argument \code{i} can be a
    matrix with as many columns as there are dimensions of \code{x}; the
    result is then a vector with elements corresponding to the sets of
    indices in each row of \code{i}.

    An index value of \code{NULL} is treated as if it were \code{integer(0)}.
  }

\item{drop}{For matrices and arrays.  If \code{TRUE} the result is
    coerced to the lowest possible dimension (see the examples).  This
    only works for extracting elements, not for the replacement.  See
    \code{\link{drop}} for further details.
  }

\item{object}{Any R object}

\item{...}{further potential arguments passed to methods.}

\item{f}{a \sQuote{factor} in the sense that \code{\link{as.factor}(f)}
    defines the grouping, or a list of such factors in which case their
    interaction is used for the grouping.}

\item{data}{
    For the \code{formula} methods, a data frame (or more precisely,
    anything that is a valid \code{envir} argument in
    \code{\link{eval}}, e.g., a list or an environment) containing values
    for any variables in the formula, as well as \code{groups} and
    \code{subset} if applicable.  If not found in \code{data}, or if
    \code{data} is unspecified, the variables are looked for in the
    environment of the formula.  For other methods (where \code{x} is
    not a formula), \code{data} is usually ignored, often with a warning
    if it is explicitly specified.
  }

\item{subset}{
    An expression that evaluates to a logical or integer indexing
    vector.  Like \code{groups}, it is evaluated in \code{data}.  Only
    the resulting rows of \code{data} are used for the plot.  If
    \code{subscripts} is \code{TRUE}, the subscripts provided to the
    panel function will be indices referring to the rows of \code{data}
    prior to the subsetting.  Whether levels of factors in the data
    frame that are unused after the subsetting will be dropped depends
    on the \code{drop.unused.levels} argument.
  }
}
\description{
It is a list of ncdfFlowSet objects
}
\section{Objects from the Class}{

Objects can be created by coercing a list of ncdfFlowSet objects
as("ncdfFlowList",nclist = .... #a list of ncdfFlowSet objects)
}
\examples{
data(GvHD)
nc1 <- ncdfFlowSet(GvHD[1])
nc2 <- ncdfFlowSet(GvHD[2])
nc3 <- ncdfFlowSet(GvHD[3])
list1 <- list(nc1, nc2, nc3)
#coerce from list to ncdfFlowList
nclist <- as(list1, "ncdfFlowList")
nclist
#coerce(collapse) from ncdfFlowList to a single flowFrame
collapsedData <- as(nclist, "flowFrame")
collapsedData
}
\seealso{
\code{\link{ncdfFlowSet}}
}

